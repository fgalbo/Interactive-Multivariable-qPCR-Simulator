<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Multivariable qPCR Simulator By Filippo D. Galbo</title>
    <!-- p5.js libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.dom.min.js"></script>

    <style>
        /* --- Global Styles & Fonts --- */
        body { font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; display: flex; flex-direction: column; align-items: center; padding: 25px 15px; background-color: #f4f7f9; color: #334155; line-height: 1.5; }
        h1 { color: #1e40af; text-align: center; margin-bottom: 5px; font-size: 2em; font-weight: 600; }
        .attribution { color: #64748b; text-align: center; font-size: 0.9em; margin-bottom: 25px; }

        /* --- Layout Container --- */
        .container { display: flex; flex-wrap: wrap; justify-content: center; gap: 35px; width: 95%; max-width: 1450px; }

        /* --- Controls Panel --- */
        #controls { background-color: #ffffff; padding: 25px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); border: 1px solid #e2e8f0; width: 410px; display: flex; flex-direction: column; gap: 20px; order: 1; align-self: flex-start; }
        .control-group { border: none; border-top: 1px solid #e2e8f0; padding: 20px 5px 5px 5px; }
        .control-group:first-child { border-top: none; padding-top: 0; }
        .control-group h3 { margin-top: 0; margin-bottom: 15px; font-size: 1.15em; color: #1e3a8a; border-bottom: none; padding-bottom: 0; font-weight: 600; display: flex; align-items: center; /* Align title elements */}
        /* Target Name Input Styling */
        .target-name-input {
             font-size: 1em; padding: 4px 8px; border: 1px solid #cbd5e1; border-radius: 4px; margin-left: 10px; /* Space after color box */ flex-grow: 1; /* Take remaining space */ min-width: 100px;
             transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .target-name-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3); outline: none;}
        .target-name-input:disabled { background-color: #f1f5f9; cursor: not-allowed;}

        label, .label { display: block; margin-bottom: 5px; font-size: 0.9em; font-weight: 500; color: #475569; }
        label.inline { display: inline-block; margin-right: 8px; font-weight: normal; font-size: 0.9em; color: #475569;}
        input[type="checkbox"] { vertical-align: middle; margin-right: 5px; accent-color: #3b82f6; width: 15px; height: 15px;}
        p.info { font-size: 0.8em; font-style: normal; color: #64748b; margin-top: -5px; margin-bottom: 12px; line-height: 1.4; background-color: #f8fafc; padding: 5px 8px; border-radius: 4px; border: 1px solid #e2e8f0; }
        input[type="range"]{ width: calc(100% - 70px); margin-right: 8px; vertical-align: middle; height: 5px; cursor: pointer; accent-color: #3b82f6; background: #e2e8f0; border-radius: 3px; outline: none; -webkit-appearance: none; appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #3b82f6; border-radius: 50%; cursor: pointer; margin-top: -6px; }
        input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; background: #3b82f6; border-radius: 50%; cursor: pointer; border: none; }
        select { width: 100%; padding: 6px 8px; vertical-align: middle; margin-bottom: 8px; border: 1px solid #cbd5e1; border-radius: 6px; background-color: #ffffff; font-size: 0.9em; }
        label[for="inhibitorTypeSelect"] { width: auto !important; display: block; }
        .value-display { display: inline-block; width: 55px; text-align: right; font-size: 0.9em; font-weight: 600; color: #1e293b; vertical-align: middle; }
        button { padding: 10px 18px; font-size: 0.95em; font-weight: 500; cursor: pointer; background-color: #3b82f6; color: white; border: none; border-radius: 6px; transition: background-color 0.2s ease, box-shadow 0.2s ease; margin: 8px 5px 0 5px; }
        button:hover { background-color: #2563eb; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        button:disabled { background-color: #94a3b8; color: #e2e8f0; cursor: not-allowed; box-shadow: none; }
        .penalty-factor-display, .eff-display { font-size: 0.85em; font-style: normal; color: #475569; margin-top: 8px; padding-left: 5px; }
        .eff-display { font-weight: 600; color: #166534; }
        .target-color-box { border: 1px solid #94a3b8; display: inline-block; width: 14px; height: 14px; margin-right: 8px; vertical-align: middle; border-radius: 2px; flex-shrink: 0; /* Prevent shrinking */}

        /* --- Canvas & Results --- */
        #canvas-container { background-color: #ffffff; padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); border: 1px solid #e2e8f0; width: 560px; order: 2; }
        #results { margin-bottom: 15px; font-size: 0.9em; width: 100%; text-align: center; padding: 12px; background-color: #eef2ff; border-radius: 8px; border: 1px solid #c7d2fe; color: #374151; line-height: 1.6; }
        #penalty-display { font-size: 0.85em; margin-top: 6px; color: #4b5563; line-height: 1.4; }
        #p5CanvasContainer { width: 100%; height: auto; border: 1px solid #d1d5db; border-radius: 4px; overflow: hidden; background-color: #fdfdfe; }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1050px) {
            body { padding: 15px 10px; } h1 { font-size: 1.8em;} .container { flex-direction: column; align-items: center; gap: 25px; }
            #controls { width: 95%; max-width: 550px; order: 1; align-self: center; padding: 20px; }
            #canvas-container { width: 95%; max-width: 560px; order: 2; padding: 15px; }
            #p5CanvasContainer canvas { display: block; max-width: 100%; height: auto !important; }
            input[type="range"]{ width: calc(100% - 65px); } select { width: 100%; }
            .target-name-input { min-width: 80px; } /* Adjust name input min-width */
        }
    </style>
</head>

<body>
    <!-- Updated Title and Added Attribution -->
    <h1>Interactive Multivariable qPCR Simulator</h1>
    <p class="attribution">By Filippo D. Galbo</p>


    <div class="container">

        <div id="controls">
             <!-- General Settings -->
            <div class="control-group">
                <h3>General Settings</h3>
                 <div> <label for="numTargetsSlider">Number of Targets: <span id="numTargetsValue" class="value-display">2</span></label> <input type="range" id="numTargetsSlider" min="1" max="4" value="2" step="1"> </div>
                 <div> <label for="maxCyclesSlider">Max Cycles: <span id="maxCyclesValue" class="value-display">40</span></label> <input type="range" id="maxCyclesSlider" min="20" max="60" value="40" step="1"> </div>
                 <div> <label for="thresholdSlider">Fluorescence Threshold (Ct): <span id="thresholdValue" class="value-display">10k</span></label> <input type="range" id="thresholdSlider" min="100" max="50000" value="10000" step="100"> <p class="info" style="margin-top: 4px;">Adjust slider or drag line on fluorescence graph after run.</p> </div>
                 <div> <label for="saturationSlider">Max Fluorescence (Saturation): <span id="saturationValue" class="value-display">100k</span></label> <input type="range" id="saturationSlider" min="5000" max="200000" value="100000" step="1000"> </div>
                 <div style="margin-top: 10px;"> <input type="checkbox" id="baselineSubtractCheckbox" checked> <label for="baselineSubtractCheckbox" class="inline">Subtract Calculated Baseline (Cycles 3-10)</label> </div>
            </div>

            <!-- Cycling Temps -->
             <div class="control-group"> <h3>Cycling Temperatures (°C)</h3> <p class="info">Ideal: 95°C, 60°C, 72°C. Deviations reduce max efficiency.</p> <div> <label for="denatureTempSlider">Denaturation: <span id="denatureTempValue" class="value-display">95</span> <span class="sub-label">°C</span></label> <input type="range" id="denatureTempSlider" min="85" max="100" value="95" step="0.5"> </div> <div> <label for="annealTempSlider">Annealing: <span id="annealTempValue" class="value-display">60</span> <span class="sub-label">°C</span></label> <input type="range" id="annealTempSlider" min="45" max="70" value="60" step="0.5"> </div> <div> <label for="extendTempSlider">Extension: <span id="extendTempValue" class="value-display">72</span> <span class="sub-label">°C</span></label> <input type="range" id="extendTempSlider" min="60" max="80" value="72" step="0.5"> </div> <div id="tempPenaltyDisplay" class="penalty-factor-display">Temp Penalty Factor: 1.00</div> </div>
             <!-- Inhibitors -->
             <div class="control-group"> <h3>Inhibitor Settings</h3> <p class="info">Simulates inhibitors affecting the overall reaction efficiency.</p> <div> <label for="inhibitorTypeSelect">Inhibitor Type:</label> <select id="inhibitorTypeSelect"> <option value="None">None</option> <option value="Heparin">Heparin (Blood)</option> <option value="Humic Acid">Humic Acid (Soil)</option> <option value="Ethanol">Ethanol (Carryover)</option> <option value="High Salt">High Salt (Buffer)</option> <option value="Melanin">Melanin (Hair/Skin)</option> </select> </div> <div> <label for="inhibitorLevelSlider">Inhibitor Level: <span id="inhibitorLevelValue" class="value-display">0</span> <span class="sub-label"></span></label> <input type="range" id="inhibitorLevelSlider" min="0" max="10" value="0" step="1"> </div> <div id="inhibitorPenaltyDisplay" class="penalty-factor-display">Inhibitor Penalty Factor: 1.00</div> </div>
             <!-- Targets -->
             <div id="target-specific-controls"></div>
             <!-- Simulation Control -->
             <div class="control-group"> <h3>Simulation Control</h3> <div style="text-align: center;"><button id="startButton">Start</button> <button id="stopButton" disabled>Stop</button> <button id="resetButton">Reset</button> </div> <p style="text-align: center; margin-top: 10px;">Status: <span id="statusLabel" style="font-weight: 600;">Idle</span></p> </div>

        </div>

        <!-- Canvas and Results -->
        <div id="canvas-container">
             <div id="results">
                 Current Cycle: <span id="currentCycleLabel" style="font-weight: bold;">0</span> / <span id="totalCyclesLabel" style="font-weight: bold;">40</span><br>
                 Max Efficiency: <span id="effEfficiencyLabel" style="font-weight: bold;">Target 1: N/A, Target 2: N/A</span><br> <!-- Placeholder -->
                 Ct Values: <span id="ctValuesLabel" style="font-weight: bold;">Target 1: N/A, Target 2: N/A</span> <!-- Placeholder -->
                 <div id="penalty-display">Penalties - Temp: 1.00 | Inhib: 1.00</div>
             </div>
             <div id="p5CanvasContainer"></div>
        </div>

    </div>

    <script>
        // --- p5.js Sketch ---
        let canvas;
        let canvasWidth = 520; let canvasHeight = 740;

        // Plot Area Definitions
        let copyPlotX, copyPlotY, copyPlotWidth, copyPlotHeight; let copyPlotMargin = { top: 45, right: 25, bottom: 55, left: 75 };
        let fluorPlotX, fluorPlotY, fluorPlotWidth, fluorPlotHeight; let fluorPlotMargin = { top: 45, right: 25, bottom: 55, left: 75 };
        let plotSpacing = 70;

        // Simulation State & Parameters
        let currentCycle = 0, maxCycles = 40;
        let fluorescenceData = [], copyNumberData = [], ctValues = [];
        let targetNames = []; // << NEW: Array for target names
        let isRunning = false, isFinished = false;
        let statusLabel, currentCycleLabel, totalCyclesLabel, ctValuesLabel, effEfficiencyLabel, penaltyDisplayLabel;
        const SIMULATION_DURATION_SECONDS = 5.0, DEFAULT_FRAMERATE = 60;
        let numTargets = 2;
        let fluorescenceThreshold = 10000, saturationLevel = 100000;
        let baseFluorescence = 50;
        const maxPossibleCopies = 1e12;
        const STOCHASTIC_THRESHOLD = 1000;
        const BASELINE_START_CYCLE = 3, BASELINE_END_CYCLE = 10;
        const BASELINE_NOISE_AMP = 15, BASELINE_DRIFT_MAX = 30;
        let denatureTemp = 95, annealTemp = 60, extendTemp = 72; const IDEAL_DENATURE = 95, IDEAL_ANNEAL = 60, IDEAL_EXTEND = 72; const DENATURE_SENSITIVITY = 0.5, ANNEAL_SENSITIVITY = 0.1, EXTEND_SENSITIVITY = 0.08; let temperaturePenalty = 1.0;
        let inhibitorType = 'None', inhibitorLevel = 0, inhibitorPenalty = 1.0; const inhibitorPotency = { 'None': 0, 'Heparin': 0.06, 'Humic Acid': 0.12, 'Ethanol': 0.02, 'High Salt': 0.03, 'Melanin': 0.05 }; let inhibitorPenaltyDisplay;
        let initialCopies = [], baseEfficiency = [], primerProbeLength = [], sequenceMatch = []; let primerPenalties = [], effectiveEfficiency = [];
        const OPTIMAL_LENGTH_MIN = 18, OPTIMAL_LENGTH_MAX = 30; const LENGTH_PENALTY_SENSITIVITY = 0.005; const MATCH_PENALTY_SENSITIVITY = 4;
        const targetColors = [ [59, 130, 246], [239, 68, 68], [34, 197, 94], [168, 85, 247] ];
        let minLogFluor, maxLogFluor, minLogCopy, maxLogCopy;
        let isDraggingThreshold = false; let thresholdDragStartY = 0; let thresholdDragStartLogValue = 0; const THRESHOLD_DRAG_SENSITIVITY = 6;

        // UI Elements
        let numTargetsSlider, maxCyclesSlider, thresholdSlider, saturationSlider, baselineSubtractCheckbox;
        let denatureTempSlider, annealTempSlider, extendTempSlider;
        let inhibitorTypeSelect, inhibitorLevelSlider;
        let startButton, stopButton, resetButton;
        let targetControls = []; // Stores { initialSlider, ..., nameInput, titleElement }
        let tempPenaltyDisplay;

        // --- Helper Functions --- (Same)
        function binomialRandom(n, p) { let successes = 0; for (let i = 0; i < floor(n); i++) { if (random() < p) successes++; } return successes; }
        function linearRegression(points) { let n = points.length; if (n < 2) return { m: 0, b: (n === 1 ? points[0][1] : 0) }; let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0; for (let i = 0; i < n; i++) { let x = points[i][0]; let y = points[i][1]; sumX += x; sumY += y; sumXY += x * y; sumX2 += x * x; } let denominator = n * sumX2 - sumX * sumX; if (abs(denominator) < 1e-9) return { m: 0, b: sumY / n }; let m = (n * sumXY - sumX * sumY) / denominator; let b = (sumY - m * sumX) / n; return { m, b }; }
        function formatNumber(num, precision = 2) { if (num === null || num === undefined) return 'N/A'; if (abs(num) >= 1e12) return (num / 1e12).toPrecision(precision) + 'T'; if (abs(num) >= 1e9) return (num / 1e9).toPrecision(precision) + 'B'; if (abs(num) >= 1e6) return (num / 1e6).toPrecision(precision) + 'M'; if (abs(num) >= 1e3) return (num / 1e3).toPrecision(precision) + 'k'; if (abs(num) < 1 && num !== 0) return num.toPrecision(precision); if (abs(num) < 100 && num !== 0) return num.toFixed(min(precision, 1)); return nfc(round(num), 0); }
        const log10 = Math.log10 || function(x) { return Math.log(x) / Math.LN10; };


        // --- Setup Function ---
        function setup() {
            canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('p5CanvasContainer');
            setupCopyPlotArea(); setupFluorPlotArea();

            // Select UI Elements...
            statusLabel = select('#statusLabel'); currentCycleLabel = select('#currentCycleLabel'); totalCyclesLabel = select('#totalCyclesLabel'); ctValuesLabel = select('#ctValuesLabel'); effEfficiencyLabel = select('#effEfficiencyLabel'); penaltyDisplayLabel = select('#penalty-display'); tempPenaltyDisplay = select('#tempPenaltyDisplay'); inhibitorPenaltyDisplay = select('#inhibitorPenaltyDisplay');
            numTargetsSlider = select('#numTargetsSlider'); maxCyclesSlider = select('#maxCyclesSlider'); thresholdSlider = select('#thresholdSlider'); saturationSlider = select('#saturationSlider'); baselineSubtractCheckbox = select('#baselineSubtractCheckbox');
            denatureTempSlider = select('#denatureTempSlider'); annealTempSlider = select('#annealTempSlider'); extendTempSlider = select('#extendTempSlider');
            inhibitorTypeSelect = select('#inhibitorTypeSelect'); inhibitorLevelSlider = select('#inhibitorLevelSlider');
            startButton = select('#startButton'); stopButton = select('#stopButton'); resetButton = select('#resetButton');

            // Event Listeners...
            numTargetsSlider.input(updateNumTargets); maxCyclesSlider.input(updateMaxCycles);
            thresholdSlider.input(() => { let newThreshold = parseFloat(thresholdSlider.value()); if (isNaN(newThreshold)) newThreshold = 10000; newThreshold = max(baseFluorescence * 1.1, newThreshold); newThreshold = min(saturationLevel * 0.95, newThreshold); fluorescenceThreshold = newThreshold; thresholdSlider.value(newThreshold); select('#thresholdValue').html(formatNumber(fluorescenceThreshold)); if (isFinished && !isRunning) { recalculateAllCtValues(); } redrawStaticElements(); });
            saturationSlider.input(updateSaturation); baselineSubtractCheckbox.changed(redrawStaticElements);
            denatureTempSlider.input(updateTemperatures); annealTempSlider.input(updateTemperatures); extendTempSlider.input(updateTemperatures);
            inhibitorTypeSelect.changed(updateInhibitorSettings); inhibitorLevelSlider.input(updateInhibitorSettings);
            startButton.mousePressed(startSimulation); stopButton.mousePressed(stopSimulation); resetButton.mousePressed(resetSimulation);

            // Initial Setup...
            updateNumTargets(); // Call first
            resetSimulation(); // Then reset
            noLoop(); frameRate(DEFAULT_FRAMERATE);
        }

        // --- Plot Area Setup ---
        function setupCopyPlotArea() { copyPlotX = copyPlotMargin.left; copyPlotY = copyPlotMargin.top; copyPlotWidth = canvasWidth - copyPlotMargin.left - copyPlotMargin.right; copyPlotHeight = max(50, (canvasHeight - copyPlotMargin.top - copyPlotMargin.bottom - plotSpacing) / 2); }
        function setupFluorPlotArea() { fluorPlotX = fluorPlotMargin.left; fluorPlotY = copyPlotY + copyPlotHeight + plotSpacing; fluorPlotWidth = canvasWidth - fluorPlotMargin.left - fluorPlotMargin.right; fluorPlotHeight = max(50, (canvasHeight - copyPlotMargin.top - copyPlotMargin.bottom - plotSpacing) / 2); }

        // --- UI Update Functions ---
        function updateNumTargets() {
            numTargets = parseInt(numTargetsSlider.value());
            select('#numTargetsValue').html(numTargets);
            let controlsDiv = select('#target-specific-controls'); controlsDiv.html('');
            targetControls = []; // Reset controls reference array
            let defaultNames = []; // Store default names temporarily

            for (let i = 0; i < numTargets; i++) {
                let targetGroup = createDiv(); targetGroup.parent(controlsDiv); targetGroup.addClass('control-group');
                if (i > 0) targetGroup.style('border-top', '1px solid #e2e8f0');

                let defaultName = `Target ${i + 1}`;
                defaultNames.push(defaultName); // Store default name

                // --- Create Title H3 (initially empty, will be populated) ---
                let titleElement = createElement('h3');
                titleElement.parent(targetGroup);
                titleElement.style('display', 'flex'); // Use flex for alignment

                // Color Box Span
                let colorBox = createSpan('');
                colorBox.addClass('target-color-box');
                colorBox.style('background-color', `rgb(${targetColors[i][0]}, ${targetColors[i][1]}, ${targetColors[i][2]})`);
                colorBox.parent(titleElement); // Add to H3

                // Name Input
                let nameInput = createInput(defaultName); // Set default value
                nameInput.addClass('target-name-input');
                nameInput.parent(titleElement); // Add to H3
                nameInput.attribute('placeholder', 'Enter Target Name');

                // --- Control elements (Sliders, etc.) ---
                let initialDiv = createDiv(); initialDiv.parent(targetGroup); createSpan(`Initial Copies (log10): `).parent(initialDiv).addClass('label'); let initialValueSpan = createSpan('3.0').parent(initialDiv).addClass('value-display'); let initialSlider = createSlider(1, 7, 3, 0.1).parent(initialDiv); initialSlider.input(() => { initialValueSpan.html(nf(initialSlider.value(), 1, 1)); if (!isRunning) { initialCopies[i] = pow(10, initialSlider.value()); } });
                let effDiv = createDiv(); effDiv.parent(targetGroup); createSpan(`Base Amplification Eff: `).parent(effDiv).addClass('label'); let effValueSpan = createSpan('95').parent(effDiv).addClass('value-display'); createSpan('%').parent(effDiv).addClass('sub-label'); let effSlider = createSlider(50, 100, 95, 1).parent(effDiv); effSlider.input(() => { effValueSpan.html(effSlider.value()); if (!isRunning) { baseEfficiency[i] = effSlider.value() / 100.0; calculateAllPenaltiesAndEfficiencies(); updateDisplays(); } });
                let lenDiv = createDiv(); lenDiv.parent(targetGroup); createSpan(`Primer/Probe Length: `).parent(lenDiv).addClass('label'); let lenValueSpan = createSpan('22').parent(lenDiv).addClass('value-display'); createSpan('bp').parent(lenDiv).addClass('sub-label'); let lenSlider = createSlider(10, 50, 22, 1).parent(lenDiv); lenSlider.input(() => { lenValueSpan.html(lenSlider.value()); if (!isRunning) { primerProbeLength[i] = lenSlider.value(); calculateAllPenaltiesAndEfficiencies(); updateDisplays(); } });
                let matchDiv = createDiv(); matchDiv.parent(targetGroup); createSpan(`Sequence Match: `).parent(matchDiv).addClass('label'); let matchValueSpan = createSpan('100').parent(matchDiv).addClass('value-display'); createSpan('%').parent(matchDiv).addClass('sub-label'); let matchSlider = createSlider(70, 100, 100, 1).parent(matchDiv); matchSlider.input(() => { matchValueSpan.html(matchSlider.value()); if (!isRunning) { sequenceMatch[i] = matchSlider.value(); calculateAllPenaltiesAndEfficiencies(); updateDisplays(); } });
                let primerPenaltyP = createP('').addClass('penalty-factor-display').parent(targetGroup); let effDisplayP = createP('').addClass('eff-display').parent(targetGroup);

                // Store references including name input and title element
                targetControls.push({ initialSlider, initialValueSpan, effSlider, effValueSpan, lenSlider, lenValueSpan, matchSlider, matchValueSpan, primerPenaltyP, effDisplayP, nameInput, titleElement });

                // Add input listener to update name immediately
                nameInput.input(() => {
                    let newName = nameInput.value();
                    targetNames[i] = newName; // Update global array
                    // No need to update h3 content directly, it *is* the input now
                    updateDisplays(); // Update results area labels
                });

                 // Initialize arrays if necessary (ensure happens *after* targetControls pushed)
                 if (targetNames.length <= i) targetNames.push(defaultName); else targetNames[i] = defaultName; // Set/reset name
                 if (initialCopies.length <= i) initialCopies.push(pow(10, initialSlider.value()));
                 if (baseEfficiency.length <= i) baseEfficiency.push(effSlider.value() / 100.0);
                 if (primerProbeLength.length <= i) primerProbeLength.push(lenSlider.value());
                 if (sequenceMatch.length <= i) sequenceMatch.push(matchSlider.value());
                 if (primerPenalties.length <= i) primerPenalties.push(1.0);
                 if (effectiveEfficiency.length <= i) effectiveEfficiency.push(0);
                 if (copyNumberData.length <= i) copyNumberData.push([]);
                 if (fluorescenceData.length <=i) fluorescenceData.push([]);
            }
            // Trim arrays
            initialCopies.length = numTargets; baseEfficiency.length = numTargets; primerProbeLength.length = numTargets; sequenceMatch.length = numTargets; primerPenalties.length = numTargets; effectiveEfficiency.length = numTargets; copyNumberData.length = numTargets; fluorescenceData.length = numTargets; targetNames.length = numTargets; targetControls.length = numTargets;

            if (!isRunning) { resetSimulation(); } // Call reset after building controls
        }
        function updateMaxCycles() { maxCycles = maxCyclesSlider.value(); select('#maxCyclesValue').html(maxCycles); totalCyclesLabel.html(maxCycles); if (!isRunning) redrawStaticElements(); }
        function updateSaturation() { saturationLevel = max(1, saturationSlider.value()); select('#saturationValue').html(formatNumber(saturationLevel)); if (!isRunning) redrawStaticElements(); }
        function updateTemperatures() { denatureTemp = denatureTempSlider.value(); annealTemp = annealTempSlider.value(); extendTemp = extendTempSlider.value(); select('#denatureTempValue').html(denatureTemp); select('#annealTempValue').html(annealTemp); select('#extendTempValue').html(extendTemp); if (!isRunning) { calculateAllPenaltiesAndEfficiencies(); updateDisplays(); } }
        function updateInhibitorSettings() { inhibitorType = inhibitorTypeSelect.value(); inhibitorLevel = inhibitorLevelSlider.value(); select('#inhibitorLevelValue').html(inhibitorLevel); if (!isRunning) { calculateAllPenaltiesAndEfficiencies(); updateDisplays(); } }
        function updateDisplays() { updateCtDisplay(); updateEffEfficiencyDisplay(); updatePenaltyFactorDisplays(); }
        function updateCtDisplay() { let ctText = []; for (let i = 0; i < numTargets; i++) { let name = targetNames?.[i] || `Target ${i + 1}`; ctText.push(`${name}: ${ctValues[i] ? ctValues[i] : 'N/A'}`); } ctValuesLabel.html(ctText.join(', ')); } // Use targetNames
        function updateEffEfficiencyDisplay() { let effText = []; for (let i = 0; i < numTargets; i++) { let name = targetNames?.[i] || `Target ${i + 1}`; let effValue = (effectiveEfficiency?.[i] ?? 0); let effPercent = effValue * 100; effText.push(`${name}: ${nf(effPercent, 0, 1)}%`); if (targetControls[i]?.effDisplayP) { targetControls[i].effDisplayP.html(`Max Eff: ${nf(effPercent, 0, 1)}%`); } } effEfficiencyLabel.html(effText.join(', ')); } // Use targetNames
        function updatePenaltyFactorDisplays() { penaltyDisplayLabel.html(`Penalties - Temp: ${nf(temperaturePenalty, 1, 2)} | Inhib: ${nf(inhibitorPenalty, 1, 2)}`); tempPenaltyDisplay.html(`Temp Penalty Factor: ${nf(temperaturePenalty, 1, 2)}`); inhibitorPenaltyDisplay.html(`Inhibitor Penalty Factor: ${nf(inhibitorPenalty, 1, 2)}`); for (let i=0; i<numTargets; i++) { if(targetControls[i]?.primerPenaltyP) { let penaltyValue = (primerPenalties?.[i] ?? 1.0); targetControls[i].primerPenaltyP.html(`Primer Penalty Factor: ${nf(penaltyValue, 1, 2)}`); } } }

        // --- Penalty Calculation Functions --- (Same)
        function calculateAllPenaltiesAndEfficiencies() { temperaturePenalty = calculateTemperaturePenalty(); inhibitorPenalty = calculateInhibitorPenalty(inhibitorType, inhibitorLevel); primerPenalties = []; effectiveEfficiency = []; for (let i = 0; i < numTargets; i++) { let length = (primerProbeLength?.[i] ?? 22); let match = (sequenceMatch?.[i] ?? 100); let baseEff = (baseEfficiency?.[i] ?? 0.95); let lengthPenalty = calculatePrimerLengthPenalty(length); let matchPenalty = calculateSequenceMatchPenalty(match); primerPenalties[i] = lengthPenalty * matchPenalty; effectiveEfficiency[i] = baseEff * temperaturePenalty * primerPenalties[i] * inhibitorPenalty; effectiveEfficiency[i] = constrain(effectiveEfficiency[i], 0, 1.0); } }
        function calculateTemperaturePenalty() { return calculateDenaturePenalty(denatureTemp) * calculateAnnealPenalty(annealTemp) * calculateExtendPenalty(extendTemp); }
        function calculateDenaturePenalty(temp) { let diff = IDEAL_DENATURE - temp; return (diff <= 0) ? 1.0 : exp(-DENATURE_SENSITIVITY * diff); }
        function calculateAnnealPenalty(temp) { let diff = abs(IDEAL_ANNEAL - temp); return exp(-ANNEAL_SENSITIVITY * pow(diff, 2)); }
        function calculateExtendPenalty(temp) { let diff = abs(IDEAL_EXTEND - temp); return exp(-EXTEND_SENSITIVITY * pow(diff, 2)); }
        function calculateInhibitorPenalty(type, level) { if (level <= 0 || type === 'None') return 1.0; let potency = inhibitorPotency[type] || 0; let reduction = potency * level * 0.1; return max(0.0, 1.0 - reduction); }
        function calculatePrimerLengthPenalty(len) { let penalty = 1.0; if (len < OPTIMAL_LENGTH_MIN) { penalty = exp(-LENGTH_PENALTY_SENSITIVITY * pow(OPTIMAL_LENGTH_MIN - len, 2)); } else if (len > OPTIMAL_LENGTH_MAX) { penalty = exp(-LENGTH_PENALTY_SENSITIVITY * pow(len - OPTIMAL_LENGTH_MAX, 2)); } return penalty; }
        function calculateSequenceMatchPenalty(match) { if (match >= 100) return 1.0; if (match < 70) return 0.0; return pow(match / 100.0, MATCH_PENALTY_SENSITIVITY); }

        // --- Simulation Core Logic ---
        function resetSimulation() {
             stopSimulation(); isRunning = false; isFinished = false; currentCycle = 0;
             numTargets = parseInt(numTargetsSlider.value());
             maxCycles = maxCyclesSlider.value(); fluorescenceThreshold = thresholdSlider.value(); saturationLevel = max(1, saturationSlider.value()); denatureTemp = denatureTempSlider.value(); annealTemp = annealTempSlider.value(); extendTemp = extendTempSlider.value(); inhibitorType = inhibitorTypeSelect.value(); inhibitorLevel = inhibitorLevelSlider.value();
             // Clear and re-initialize arrays
             initialCopies = []; baseEfficiency = []; primerProbeLength = []; sequenceMatch = []; fluorescenceData = []; copyNumberData = []; ctValues = []; primerPenalties = []; effectiveEfficiency = []; targetNames = []; // Clear target names too
            for (let i = 0; i < numTargets; i++) {
                 // Get current values from targetControls if they exist
                 initialCopies[i] = (targetControls[i]?.initialSlider) ? pow(10, targetControls[i].initialSlider.value()) : pow(10, 3);
                 baseEfficiency[i] = (targetControls[i]?.effSlider) ? targetControls[i].effSlider.value() / 100.0 : 0.95;
                 primerProbeLength[i] = (targetControls[i]?.lenSlider) ? targetControls[i].lenSlider.value() : 22;
                 sequenceMatch[i] = (targetControls[i]?.matchSlider) ? targetControls[i].matchSlider.value() : 100;
                 targetNames[i] = (targetControls[i]?.nameInput) ? targetControls[i].nameInput.value() : `Target ${i + 1}`; // Get name from input
                  // Set the input field value explicitly in case it was cleared or needs reset
                 if(targetControls[i]?.nameInput) { targetControls[i].nameInput.value(targetNames[i]); }

                 let initialFluorData = []; let currentDrift = 0;
                 initialFluorData.push(baseFluorescence + random(-BASELINE_NOISE_AMP / 2, BASELINE_NOISE_AMP / 2));
                 for (let c = 1; c <= BASELINE_END_CYCLE; c++) { let noise = random(-BASELINE_NOISE_AMP, BASELINE_NOISE_AMP); currentDrift += BASELINE_DRIFT_MAX / BASELINE_END_CYCLE * random(0.5, 1.5); initialFluorData.push(max(1, baseFluorescence + noise + currentDrift)); }
                 fluorescenceData.push(initialFluorData.slice(0, 1)); copyNumberData.push([initialCopies[i]]); ctValues.push(null); primerPenalties.push(1.0); effectiveEfficiency.push(0);
            }
            initialCopies.length = numTargets; baseEfficiency.length = numTargets; primerProbeLength.length = numTargets; sequenceMatch.length = numTargets; fluorescenceData.length = numTargets; copyNumberData.length = numTargets; ctValues.length = numTargets; primerPenalties.length = numTargets; effectiveEfficiency.length = numTargets; targetNames.length = numTargets;
             calculateAllPenaltiesAndEfficiencies();
             statusLabel.html('Idle'); currentCycleLabel.html('0'); totalCyclesLabel.html(maxCycles); updateDisplays();
             startButton.removeAttribute('disabled'); stopButton.attribute('disabled', '');
             enableControls(true); redrawStaticElements(); noLoop(); frameRate(DEFAULT_FRAMERATE);
        }
        function enableControls(enable = true) {
             let controls = [ numTargetsSlider, maxCyclesSlider, saturationSlider, baselineSubtractCheckbox, denatureTempSlider, annealTempSlider, extendTempSlider, inhibitorTypeSelect, inhibitorLevelSlider ];
             controls.forEach(ctrl => enable ? ctrl.removeAttribute('disabled') : ctrl.attribute('disabled', ''));
             if(isRunning) thresholdSlider.attribute('disabled', ''); else thresholdSlider.removeAttribute('disabled');
             targetControls.forEach(tc => { if (tc) { const action = enable ? 'removeAttribute' : 'attribute'; const params = enable ? ['disabled'] : ['disabled', '']; tc.initialSlider[action](...params); tc.effSlider[action](...params); tc.lenSlider[action](...params); tc.matchSlider[action](...params); tc.nameInput[action](...params); } }); // Enable/disable name input
        }
        function startSimulation() { if (isRunning) return; resetSimulation(); isRunning = true; isFinished = false; statusLabel.html('Running...'); startButton.attribute('disabled', ''); stopButton.removeAttribute('disabled'); enableControls(false); let targetFrameRate = max(1, maxCycles / SIMULATION_DURATION_SECONDS); frameRate(targetFrameRate); print(`Starting simulation. Target frameRate: ${targetFrameRate.toFixed(1)} fps for ${maxCycles} cycles over ~${SIMULATION_DURATION_SECONDS}s.`); loop(); }
        function stopSimulation() { isRunning = false; if (currentCycle > 0 && currentCycle <= maxCycles && !isFinished) { statusLabel.html('Stopped'); } else if (isFinished) { statusLabel.html('Finished');} else { statusLabel.html('Idle');} stopButton.attribute('disabled', ''); startButton.removeAttribute('disabled'); enableControls(true); noLoop(); frameRate(DEFAULT_FRAMERATE); }
        function runCycle() { /* ... (Same as previous version) ... */ if (!isRunning || currentCycle >= maxCycles) { if (isRunning) { statusLabel.html('Finished'); isRunning = false; isFinished = true; stopButton.attribute('disabled', ''); startButton.removeAttribute('disabled'); enableControls(true); noLoop(); frameRate(DEFAULT_FRAMERATE); } return; } currentCycle++; for (let i = 0; i < numTargets; i++) { if (!fluorescenceData[i] || !copyNumberData[i]) continue; let currentFluor = fluorescenceData[i][currentCycle - 1]; let prevCopyNum = copyNumberData[i][currentCycle - 1]; let maxEff = effectiveEfficiency[i]; let exhaustionFactor = 1.0; if (maxPossibleCopies > 0) { exhaustionFactor = max(0, 1.0 - (prevCopyNum / maxPossibleCopies)); } let cycleEfficiency = max(0, maxEff * exhaustionFactor); let newCopyNum = prevCopyNum; let newFluor = currentFluor; if (currentCycle <= BASELINE_END_CYCLE) { let noise = random(-BASELINE_NOISE_AMP, BASELINE_NOISE_AMP); let drift = (BASELINE_DRIFT_MAX / BASELINE_END_CYCLE) * currentCycle * random(0.8, 1.2); newFluor = max(1, baseFluorescence + noise + drift); newCopyNum = prevCopyNum; } else if (cycleEfficiency > 0) { let numAmplified = 0; if (prevCopyNum < STOCHASTIC_THRESHOLD && prevCopyNum > 0) { numAmplified = binomialRandom(prevCopyNum, cycleEfficiency); newCopyNum = prevCopyNum + numAmplified; } else if (prevCopyNum >= STOCHASTIC_THRESHOLD) { numAmplified = prevCopyNum * cycleEfficiency; newCopyNum = prevCopyNum + numAmplified; } let amplifiedFluorPortion = currentFluor * cycleEfficiency; newFluor = currentFluor + amplifiedFluorPortion; } newFluor = min(newFluor, saturationLevel); newFluor = max(newFluor, baseFluorescence * 0.8); newCopyNum = max(newCopyNum, 0); fluorescenceData[i].push(newFluor); copyNumberData[i].push(newCopyNum); if (ctValues[i] === null && newFluor >= fluorescenceThreshold) { let prevFluor = fluorescenceData[i][currentCycle - 1]; if (newFluor > prevFluor && newFluor >= fluorescenceThreshold) { let fraction = (fluorescenceThreshold - prevFluor) / (newFluor - prevFluor); ctValues[i] = nf((currentCycle - 1) + fraction, 0, 1); } else if (newFluor >= fluorescenceThreshold && prevFluor < fluorescenceThreshold) { ctValues[i] = nf(currentCycle, 0, 1); } } } currentCycleLabel.html(currentCycle); updateCtDisplay(); }
        function recalculateAllCtValues() { /* ... (Same as previous version) ... */ if (!fluorescenceData) return; for (let i = 0; i < numTargets; i++) { ctValues[i] = null; if (!fluorescenceData[i] || fluorescenceData[i].length <= 1) continue; for (let c = 1; c < fluorescenceData[i].length; c++) { let currentFluor = fluorescenceData[i][c]; let prevFluor = fluorescenceData[i][c - 1]; if (currentFluor >= fluorescenceThreshold && prevFluor < fluorescenceThreshold) { if (currentFluor > prevFluor) { let fraction = (fluorescenceThreshold - prevFluor) / (currentFluor - prevFluor); ctValues[i] = nf((c - 1) + fraction, 0, 1); } else { ctValues[i] = nf(c, 0, 1); } break; } } if (ctValues[i] === null && fluorescenceData[i][0] >= fluorescenceThreshold) { ctValues[i] = nf(0, 0, 1); } } updateCtDisplay(); }

        // --- Drawing Functions --- (Same logic, potentially minor style tweaks if needed)
        function draw() { if (isRunning) { runCycle(); } background(255); drawCopyNumberPlot(); drawFluorescencePlot(); }
        function redrawStaticElements() { background(255); drawCopyNumberPlot(); drawFluorescencePlot(); }
        // --- Plot 1 (Top): Copy Number ---
        function drawCopyNumberPlot() { /* ... (Axis calc same) ... */ let maxCopiesFound = 1; for (let i = 0; i < numTargets; i++) { if (copyNumberData?.[i]?.length > 0) { let targetMax = max(copyNumberData[i]); if (targetMax > maxCopiesFound) maxCopiesFound = targetMax; } } let minCopiesFound = maxCopiesFound; for (let i = 0; i < numTargets; i++) { if (initialCopies?.[i] < minCopiesFound && initialCopies[i] > 0) minCopiesFound = initialCopies[i]; } minCopiesFound = max(1, minCopiesFound); maxLogCopy = log10(max(10, maxCopiesFound * 1.5)); minLogCopy = log10(minCopiesFound * 0.8); minLogCopy = max(0, minLogCopy); /* Draw Background / Borders */ fill(255); stroke(200); strokeWeight(1); rect(copyPlotX, copyPlotY, copyPlotWidth, copyPlotHeight); /* Titles and Labels */ fill('#334155'); noStroke(); textAlign(CENTER, BOTTOM); textSize(14);textFont('sans-serif'); text('Copy Number vs. Cycle', copyPlotX + copyPlotWidth / 2, copyPlotY - 12); textAlign(CENTER, CENTER); textSize(11); fill('#475569'); text('Cycle Number', copyPlotX + copyPlotWidth / 2, copyPlotY + copyPlotHeight + copyPlotMargin.bottom / 1.8); push(); translate(copyPlotX - copyPlotMargin.left / 1.5, copyPlotY + copyPlotHeight / 2); rotate(-HALF_PI); textAlign(CENTER, CENTER); text('Copy Number (Log Scale)', 0, 0); pop(); /* Axes and Curves */ drawCopyNumberAxes(); for (let i = 0; i < numTargets; i++) drawCopyNumberCurve(i); }
        function drawCopyNumberAxes() { /* ... (Styled axes) ... */ stroke('#e2e8f0'); strokeWeight(0.8); textAlign(CENTER, TOP); textSize(10); fill('#64748b'); let xTickInterval = max(1, floor(maxCycles / 10)); xTickInterval = ceil(xTickInterval / 5) * 5; for (let c = 0; c <= maxCycles; c += xTickInterval) { let x = map(c, 0, maxCycles, copyPlotX, copyPlotX + copyPlotWidth); line(x, copyPlotY, x, copyPlotY + copyPlotHeight); stroke('#94a3b8'); line(x, copyPlotY + copyPlotHeight, x, copyPlotY + copyPlotHeight + 4); noStroke(); text(c, x, copyPlotY + copyPlotHeight + 7); stroke('#e2e8f0'); } textAlign(RIGHT, CENTER); let numYTicks = 5; for (let i = 0; i <= numYTicks; i++) { let logCopyValue = map(i, 0, numYTicks, minLogCopy, maxLogCopy); if (isNaN(logCopyValue) || !isFinite(logCopyValue)) continue; let y = map(logCopyValue, minLogCopy, maxLogCopy, copyPlotY + copyPlotHeight, copyPlotY); if (y < copyPlotY || y > copyPlotY + copyPlotHeight + 1) continue; let realCopyValue = pow(10, logCopyValue); stroke('#e2e8f0'); line(copyPlotX, y, copyPlotX + copyPlotWidth, y); stroke('#94a3b8'); line(copyPlotX - 4, y, copyPlotX, y); noStroke(); text(formatNumber(realCopyValue, 2), copyPlotX - 7, y); stroke('#e2e8f0'); } }
        function drawCopyNumberCurve(targetIndex) { /* ... (Styled curve) ... */ if (!copyNumberData?.[targetIndex] || copyNumberData[targetIndex].length <= 1) return; let col = targetColors[targetIndex]; stroke(col[0], col[1], col[2]); strokeWeight(2.2); noFill(); beginShape(); for (let c = 0; c < copyNumberData[targetIndex].length; c++) { let copies = max(1, copyNumberData[targetIndex][c]); let x = map(c, 0, maxCycles, copyPlotX, copyPlotX + copyPlotWidth); let logCopy = log10(copies); if(isNaN(logCopy) || !isFinite(logCopy)) continue; logCopy = constrain(logCopy, minLogCopy, maxLogCopy); let y = map(logCopy, minLogCopy, maxLogCopy, copyPlotY + copyPlotHeight, copyPlotY); if(isNaN(y)) continue; y = constrain(y, copyPlotY, copyPlotY + copyPlotHeight); if (x >= copyPlotX) vertex(x, y); else if (c === 0) vertex(copyPlotX, y); } endShape(); }
        // --- Plot 2 (Bottom): Fluorescence ---
        function drawFluorescencePlot() { /* ... (Axis calc same) ... */ maxLogFluor = log10(max(saturationLevel * 1.1, baseFluorescence * 10)); minLogFluor = log10(max(1, baseFluorescence * 0.8)); /* Draw Background / Borders */ fill(255); stroke(200); strokeWeight(1); rect(fluorPlotX, fluorPlotY, fluorPlotWidth, fluorPlotHeight); /* Titles and Labels */ fill('#334155'); noStroke(); textAlign(CENTER, BOTTOM); textSize(14);textFont('sans-serif'); text('Fluorescence vs. Cycle', fluorPlotX + fluorPlotWidth / 2, fluorPlotY - 12); textAlign(CENTER, CENTER); textSize(11); fill('#475569'); text('Cycle Number', fluorPlotX + fluorPlotWidth / 2, fluorPlotY + fluorPlotHeight + fluorPlotMargin.bottom / 1.8); push(); translate(fluorPlotX - fluorPlotMargin.left / 1.5, fluorPlotY + fluorPlotHeight / 2); rotate(-HALF_PI); textAlign(CENTER, CENTER); text('Fluorescence (Log Scale)', 0, 0); pop(); /* Axes, Threshold, Curves */ drawFluorescenceAxes(); drawFluorescenceThresholdLine(); for (let i = 0; i < numTargets; i++) drawFluorescenceCurve(i); }
        function drawFluorescenceAxes() { /* ... (Styled axes) ... */ stroke('#e2e8f0'); strokeWeight(0.8); textAlign(CENTER, TOP); textSize(10); fill('#64748b'); let xTickInterval = max(1, floor(maxCycles / 10)); xTickInterval = ceil(xTickInterval / 5) * 5; for (let c = 0; c <= maxCycles; c += xTickInterval) { let x = map(c, 0, maxCycles, fluorPlotX, fluorPlotX + fluorPlotWidth); line(x, fluorPlotY, x, fluorPlotY + fluorPlotHeight); stroke('#94a3b8'); line(x, fluorPlotY + fluorPlotHeight, x, fluorPlotY + fluorPlotHeight + 4); noStroke(); text(c, x, fluorPlotY + fluorPlotHeight + 7); stroke('#e2e8f0'); } textAlign(RIGHT, CENTER); let numYTicks = 5; for (let i = 0; i <= numYTicks; i++) { let logFluorValue = map(i, 0, numYTicks, minLogFluor, maxLogFluor); if (isNaN(logFluorValue) || !isFinite(logFluorValue)) continue; let y = map(logFluorValue, minLogFluor, maxLogFluor, fluorPlotY + fluorPlotHeight, fluorPlotY); if (y < fluorPlotY || y > fluorPlotY + fluorPlotHeight + 1) continue; let realFluorValue = pow(10, logFluorValue); stroke('#e2e8f0'); line(fluorPlotX, y, fluorPlotX + fluorPlotWidth, y); stroke('#94a3b8'); line(fluorPlotX - 4, y, fluorPlotX, y); noStroke(); text(formatNumber(realFluorValue, 2), fluorPlotX - 7, y); stroke('#e2e8f0'); } }
        function drawFluorescenceThresholdLine() { /* ... (Styled threshold line) ... */ let logThreshold = log10(max(1, fluorescenceThreshold)); if (isNaN(logThreshold) || !isFinite(logThreshold) || !isFinite(minLogFluor) || !isFinite(maxLogFluor) || logThreshold < minLogFluor || logThreshold > maxLogFluor) return; let yThreshold = map(logThreshold, minLogFluor, maxLogFluor, fluorPlotY + fluorPlotHeight, fluorPlotY); if (isNaN(yThreshold) || yThreshold < fluorPlotY - 1 || yThreshold > fluorPlotY + fluorPlotHeight + 1) return; let isHovering = abs(mouseY - yThreshold) < THRESHOLD_DRAG_SENSITIVITY && mouseX > fluorPlotX && mouseX < fluorPlotX + fluorPlotWidth && !isRunning; strokeWeight(isDraggingThreshold || isHovering ? 2.5 : 1.8); stroke(34, 197, 94, isDraggingThreshold || isHovering ? 230 : 180); drawingContext.setLineDash([6, 4]); line(fluorPlotX, yThreshold, fluorPlotX + fluorPlotWidth, yThreshold); drawingContext.setLineDash([]); fill(34, 197, 94); noStroke(); textSize(10); textAlign(RIGHT, BOTTOM); text('Ct Threshold', fluorPlotX + fluorPlotWidth - 5, yThreshold - 3); strokeWeight(1); }
        function drawFluorescenceCurve(targetIndex) { /* ... (Styled curve + baseline logic) ... */ if (!fluorescenceData?.[targetIndex] || fluorescenceData[targetIndex].length === 0) return; let dataToPlot = fluorescenceData[targetIndex]; let doBaselineSubtraction = baselineSubtractCheckbox.checked(); if (doBaselineSubtraction && fluorescenceData[targetIndex].length > BASELINE_START_CYCLE) { let baselinePoints = []; let endCalcCycle = min(BASELINE_END_CYCLE, fluorescenceData[targetIndex].length - 1); for (let c = BASELINE_START_CYCLE; c <= endCalcCycle; c++) { if (fluorescenceData[targetIndex][c] !== undefined) { baselinePoints.push([c, fluorescenceData[targetIndex][c]]); } } if (baselinePoints.length >= 2) { let baselineParams = linearRegression(baselinePoints); let subtractedData = []; for (let c = 0; c < fluorescenceData[targetIndex].length; c++) { let originalValue = fluorescenceData[targetIndex][c]; let baselineValue = baselineParams.m * c + baselineParams.b; subtractedData.push(max(1, originalValue - baselineValue)); } dataToPlot = subtractedData; } } let col = targetColors[targetIndex]; stroke(col[0], col[1], col[2]); strokeWeight(2.2); noFill(); beginShape(); for (let c = 0; c < dataToPlot.length; c++) { let fluor = max(1, dataToPlot[c]); let x = map(c, 0, maxCycles, fluorPlotX, fluorPlotX + fluorPlotWidth); let logFluor = log10(fluor); if(isNaN(logFluor) || !isFinite(logFluor) || !isFinite(minLogFluor) || !isFinite(maxLogFluor)) continue; logFluor = constrain(logFluor, minLogFluor, maxLogFluor); let y = map(logFluor, minLogFluor, maxLogFluor, fluorPlotY + fluorPlotHeight, fluorPlotY); if(isNaN(y)) continue; y = constrain(y, fluorPlotY, fluorPlotY + fluorPlotHeight); if (x >= fluorPlotX) vertex(x, y); else if (c === 0) vertex(fluorPlotX, y); } endShape(); if (ctValues[targetIndex] !== null) { let ctCycle = parseFloat(ctValues[targetIndex]); if (!isNaN(ctCycle)) { let ctX = map(ctCycle, 0, maxCycles, fluorPlotX, fluorPlotX + fluorPlotWidth); let fluorAtCt = 1; let cycleFloor = floor(ctCycle); let cycleCeil = ceil(ctCycle); if (ctCycle >= 0 && ctCycle < dataToPlot.length) { if(cycleFloor === cycleCeil && cycleFloor < dataToPlot.length) fluorAtCt = dataToPlot[cycleFloor]; else if (cycleFloor >= 0 && cycleCeil < dataToPlot.length) fluorAtCt = map(ctCycle, cycleFloor, cycleCeil, dataToPlot[cycleFloor], dataToPlot[cycleCeil]); else if (cycleFloor >= 0 && cycleFloor < dataToPlot.length) fluorAtCt = dataToPlot[cycleFloor]; } fluorAtCt = max(1, fluorAtCt); let logFluorCt = log10(fluorAtCt); if(isNaN(logFluorCt) || !isFinite(logFluorCt) || !isFinite(minLogFluor) || !isFinite(maxLogFluor)) return; logFluorCt = constrain(logFluorCt, minLogFluor, maxLogFluor); let ctY = map(logFluorCt, minLogFluor, maxLogFluor, fluorPlotY + fluorPlotHeight, fluorPlotY); if(isNaN(ctY)) return; ctY = constrain(ctY, fluorPlotY, fluorPlotY + fluorPlotHeight); if (ctX >= fluorPlotX && ctX <= fluorPlotX + fluorPlotWidth) { fill(col[0], col[1], col[2]); noStroke(); ellipse(ctX, ctY, 8, 8); } } } }

        // --- Mouse Interaction --- (Same logic)
        function mousePressed() { if (isRunning) return; let logThreshold = log10(max(1, fluorescenceThreshold)); if (isNaN(logThreshold) || !isFinite(logThreshold) || !isFinite(minLogFluor) || !isFinite(maxLogFluor)) return; let yThreshold = map(logThreshold, minLogFluor, maxLogFluor, fluorPlotY + fluorPlotHeight, fluorPlotY); if (isNaN(yThreshold)) return; if (mouseY > yThreshold - THRESHOLD_DRAG_SENSITIVITY && mouseY < yThreshold + THRESHOLD_DRAG_SENSITIVITY && mouseX > fluorPlotX && mouseX < fluorPlotX + fluorPlotWidth) { isDraggingThreshold = true; thresholdDragStartY = mouseY; thresholdDragStartLogValue = logThreshold; cursor(HAND); document.body.style.userSelect = 'none'; document.body.style.webkitUserSelect = 'none'; } }
        function mouseDragged() { if (isDraggingThreshold) { if (minLogFluor === undefined || maxLogFluor === undefined || !isFinite(minLogFluor) || !isFinite(maxLogFluor) || fluorPlotHeight <= 0) return; let deltaY = mouseY - thresholdDragStartY; let deltaLogFluor = map(deltaY, 0, -fluorPlotHeight, 0, maxLogFluor - minLogFluor); let newLogThreshold = thresholdDragStartLogValue + deltaLogFluor; newLogThreshold = constrain(newLogThreshold, minLogFluor, maxLogFluor); let newThreshold = pow(10, newLogThreshold); newThreshold = max(baseFluorescence * 1.1, newThreshold); newThreshold = min(saturationLevel * 0.95, newThreshold); fluorescenceThreshold = newThreshold; thresholdSlider.value(newThreshold); select('#thresholdValue').html(formatNumber(newThreshold)); if (isFinished) { recalculateAllCtValues(); } redrawStaticElements(); } }
        function mouseReleased() { if (isDraggingThreshold) { isDraggingThreshold = false; cursor(ARROW); document.body.style.userSelect = 'auto'; document.body.style.webkitUserSelect = 'auto'; if (isFinished) { recalculateAllCtValues(); redrawStaticElements(); } } }

    </script>

</body>
</html>